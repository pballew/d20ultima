class_name Player
extends Character

# Backup of Player.gd (disabled) â€” project switched to C# Player.cs.
# Kept here so the original GDScript can be referred to later if needed.
# Original content follows (disabled to avoid parse errors during startup):

--- ORIGINAL PLAYER.GD CONTENT (disabled) ---

class_name Player
extends Character

# Minimal Player used during porting. Exposes the small API Main expects.

@export var movement_speed: float = 200.0

signal movement_finished
signal encounter_started
signal camping_started
signal town_name_display(town_name: String)

var _target_position: Vector2
var _is_moving: bool = false
var _is_in_combat: bool = false

func _ready() -> void:
    _target_position = global_position

func load_from_character_data(char_data) -> void:
    if typeof(char_data) == TYPE_DICTIONARY:
        character_name = char_data.get("character_name", character_name)
        level = int(char_data.get("level", level))
        max_health = int(char_data.get("max_health", max_health))
        current_health = int(char_data.get("current_health", current_health))
        experience = int(char_data.get("experience", experience))
        global_position = char_data.get("world_position", global_position)

func save_to_character_data() -> Dictionary:
    var d: Dictionary = {}
    d["character_name"] = character_name
    d["level"] = level
    d["max_health"] = max_health
    d["current_health"] = current_health
    d["experience"] = experience
    d["world_position"] = global_position
    return d

func enter_combat() -> void:
    _is_in_combat = true

func exit_combat() -> void:
    _is_in_combat = false

func move_to_tile(new_pos: Vector2) -> void:
    _target_position = new_pos
    _is_moving = true

func _physics_process(delta: float) -> void:
    if _is_moving:
        global_position = global_position.move_toward(_target_position, movement_speed * delta)
        if global_position.distance_to(_target_position) < 1.0:
            global_position = _target_position
            _is_moving = false
            emit_signal("movement_finished")

--- END ORIGINAL ---
class_name Player
extends Character

# Minimal Player used during porting. Exposes the small API Main expects.

@export var movement_speed: float = 200.0

signal movement_finished
signal encounter_started
signal camping_started
signal town_name_display(town_name: String)

var _target_position: Vector2
var _is_moving: bool = false
var _is_in_combat: bool = false

func _ready() -> void:
    _target_position = global_position

func load_from_character_data(char_data) -> void:
    if typeof(char_data) == TYPE_DICTIONARY:
        character_name = char_data.get("character_name", character_name)
        level = int(char_data.get("level", level))
        max_health = int(char_data.get("max_health", max_health))
        current_health = int(char_data.get("current_health", current_health))
        experience = int(char_data.get("experience", experience))
        global_position = char_data.get("world_position", global_position)

func save_to_character_data() -> Dictionary:
    var d: Dictionary = {}
    d["character_name"] = character_name
    d["level"] = level
    d["max_health"] = max_health
    d["current_health"] = current_health
    d["experience"] = experience
    d["world_position"] = global_position
    return d

func enter_combat() -> void:
    _is_in_combat = true

func exit_combat() -> void:
    _is_in_combat = false

func move_to_tile(new_pos: Vector2) -> void:
    _target_position = new_pos
    _is_moving = true

func _physics_process(delta: float) -> void:
    if _is_moving:
        global_position = global_position.move_toward(_target_position, movement_speed * delta)
        if global_position.distance_to(_target_position) < 1.0:
            global_position = _target_position
            _is_moving = false
            emit_signal("movement_finished")

func load_from_character_data(char_data) -> void:
	if typeof(char_data) == TYPE_DICTIONARY:
		character_name = char_data.get("character_name", character_name)
		level = int(char_data.get("level", level))
		max_health = int(char_data.get("max_health", max_health))
		current_health = int(char_data.get("current_health", current_health))
		experience = int(char_data.get("experience", experience))
		global_position = char_data.get("world_position", global_position)

func save_to_character_data() -> Dictionary:
	var d: Dictionary = {}
	d["character_name"] = character_name
	d["level"] = level
	d["max_health"] = max_health
	d["current_health"] = current_health
	d["experience"] = experience
	d["world_position"] = global_position
	return d

func enter_combat() -> void:
	_is_in_combat = true

func exit_combat() -> void:
	_is_in_combat = false

func move_to_tile(new_pos: Vector2) -> void:
	_target_position = new_pos
	_is_moving = true

func set_camera_target(pos: Vector2) -> void:
	pass

func get_encounter_difficulty_for_terrain(terrain_type: int) -> float:
	return 1.0

func _physics_process(delta: float) -> void:
	if _is_moving:
		global_position = global_position.move_toward(_target_position, movement_speed * delta)
		if global_position.distance_to(_target_position) < 1.0:
			global_position = _target_position
			_is_moving = false
			emit_signal("movement_finished")
class_name Player
extends Character

# Minimal Player implementation required by Main.gd and other systems.
# Keeps the file very small to avoid parse issues while port work continues.

@export var movement_speed: float = 200.0

signal movement_finished
signal encounter_started
signal camping_started
signal town_name_display(town_name: String)

var _target_position: Vector2
var _is_moving: bool = false
var _is_in_combat: bool = false

func _ready() -> void:
	_target_position = global_position

func load_from_character_data(char_data) -> void:
	if typeof(char_data) == TYPE_DICTIONARY:
		character_name = char_data.get("character_name", character_name)
		level = int(char_data.get("level", level))
		max_health = int(char_data.get("max_health", max_health))
		current_health = int(char_data.get("current_health", current_health))
		experience = int(char_data.get("experience", experience))
		global_position = char_data.get("world_position", global_position)

func save_to_character_data() -> Dictionary:
	var d: Dictionary = {}
	d["character_name"] = character_name
	d["level"] = level
	d["max_health"] = max_health
	d["current_health"] = current_health
	d["experience"] = experience
	d["world_position"] = global_position
	return d

func enter_combat() -> void:
	_is_in_combat = true

func exit_combat() -> void:
	_is_in_combat = false

func move_to_tile(new_pos: Vector2) -> void:
	_target_position = new_pos
	_is_moving = true

func set_camera_target(pos: Vector2) -> void:
	# Minimal stub; Main checks for this method before calling
	pass

func get_encounter_difficulty_for_terrain(terrain_type: int) -> float:
	# Minimal stub returning a neutral difficulty multiplier
	return 1.0

func _physics_process(delta: float) -> void:
	if _is_moving:
		global_position = global_position.move_toward(_target_position, movement_speed * delta)
		if global_position.distance_to(_target_position) < 1.0:
			global_position = _target_position
			_is_moving = false
			emit_signal("movement_finished")



class_name Player
extends Character

# Minimal Player implementation required by Main.gd and other systems.
# Keeps the file very small to avoid parse issues while port work continues.

@export var movement_speed: float = 200.0

signal movement_finished
signal encounter_started
signal camping_started
signal town_name_display(town_name: String)

var _target_position: Vector2
var _is_moving: bool = false
var _is_in_combat: bool = false

func _ready() -> void:
	_target_position = global_position

func load_from_character_data(char_data) -> void:
	if typeof(char_data) == TYPE_DICTIONARY:
		character_name = char_data.get("character_name", character_name)
		level = int(char_data.get("level", level))
		max_health = int(char_data.get("max_health", max_health))
		current_health = int(char_data.get("current_health", current_health))
		experience = int(char_data.get("experience", experience))
		global_position = char_data.get("world_position", global_position)

func save_to_character_data() -> Dictionary:
	var d: Dictionary = {}
	d["character_name"] = character_name
	d["level"] = level
	d["max_health"] = max_health
	d["current_health"] = current_health
	d["experience"] = experience
	d["world_position"] = global_position
	return d

func enter_combat() -> void:
	_is_in_combat = true

func exit_combat() -> void:
	_is_in_combat = false

func move_to_tile(new_pos: Vector2) -> void:
	_target_position = new_pos
	_is_moving = true

func set_camera_target(pos: Vector2) -> void:
	# Minimal stub; Main checks for this method before calling
	pass

func get_encounter_difficulty_for_terrain(terrain_type: int) -> float:
	# Minimal stub returning a neutral difficulty multiplier
	return 1.0

func _physics_process(delta: float) -> void:
	if _is_moving:
		global_position = global_position.move_toward(_target_position, movement_speed * delta)
		if global_position.distance_to(_target_position) < 1.0:
			global_position = _target_position
			_is_moving = false
			emit_signal("movement_finished")




*** End Patch
							found_count += 1
							DebugLogger.info("*** FOUND TOWN #%s: %s at position: %s ***" % [found_count, town_data.get("name", "Unknown"), check_pos])

			# Also specifically test the known town position
			DebugLogger.info("=== TESTING KNOWN TOWN POSITION ===")
			var known_pos = Vector2(-192, -128)
			var known_town = null
			if terrain and terrain.has_method("get_town_data_at_position"):
				known_town = terrain.get_town_data_at_position(known_pos)
			if known_town and not known_town.is_empty():
				DebugLogger.info("SUCCESS: Found town at known position %s: %s" % [known_pos, known_town])
			else:
				DebugLogger.info("FAILED: No town found at known position %s" % known_pos)

			DebugLogger.info("=== FOUND %s TOWNS IN SEARCH AREA ===" % found_count)

			# Test specific positions to see if the function works at all
			DebugLogger.info("=== TESTING SPECIFIC POSITIONS ===")
			var test_positions = [
				Vector2(0, 0), Vector2(32, 32), Vector2(64, 64), Vector2(100, 100),
				Vector2(200, 200), Vector2(400, 400), Vector2(500, 500)
			]
			for test_pos in test_positions:
				var town_data = null
				if terrain and terrain.has_method("get_town_data_at_position"):
					town_data = terrain.get_town_data_at_position(test_pos)
				if town_data and not town_data.is_empty():
					DebugLogger.info("TOWN at test position %s: %s" % [test_pos, town_data])
				else:
					DebugLogger.info("No town at test position %s" % test_pos)


			# Try to get direct section information from the terrain system
			DebugLogger.info("=== DIRECT TERRAIN DEBUG ===")
			if terrain and terrain.has_method("print_section_towns"):
				terrain.print_section_towns(Vector2i(0, 0))
			else:
				DebugLogger.info("No print_section_towns method available")
			
			DebugLogger.info("=== END TOWN SEARCH ===")

func check_for_town_at_position(world_pos: Vector2):
	"""Check if the given position has a town and show dialog if found"""
	DebugLogger.info("=== CHECK_FOR_TOWN_AT_POSITION DEBUG ===")
	DebugLogger.info("DEBUG: Input world position: %s" % world_pos)
	DebugLogger.info("DEBUG: TILE_SIZE: %s" % TILE_SIZE)

	# Convert player center position to tile top-left corner position
	# Player position is center of tile, but towns are stored using top-left coordinates
	var tile_top_left = Vector2(
		floor(world_pos.x / TILE_SIZE) * TILE_SIZE,
		floor(world_pos.y / TILE_SIZE) * TILE_SIZE
	)
	DebugLogger.info("DEBUG: Converted to tile top-left: %s" % tile_top_left)

	# Also calculate the tile coordinates for debugging
	var tile_coords = Vector2i(int(tile_top_left.x / TILE_SIZE), int(tile_top_left.y / TILE_SIZE))
	DebugLogger.info("DEBUG: Tile coordinates: %s" % tile_coords)

	# Get terrain system (try both TileMap and legacy implementations)
	var terrain = get_parent().get_node_or_null("EnhancedTerrainTileMap")
	if not terrain:
		terrain = get_parent().get_node_or_null("EnhancedTerrain")

	DebugLogger.info("DEBUG: Terrain found: %s" % (terrain != null))
	if terrain and terrain.has_method("get_town_data_at_position"):
		DebugLogger.info("DEBUG: Calling get_town_data_at_position with tile top-left")
		var town_data = terrain.get_town_data_at_position(tile_top_left)
		DebugLogger.info("DEBUG: Town data result: %s" % town_data)
		if not town_data.is_empty():
			var town_name = town_data.get("name", "Unknown Town")
			DebugLogger.info("Player stepped on town: %s" % town_name)

			# Emit signal for town name display
			DebugLogger.info("DEBUG: About to emit town_name_display signal with: %s" % town_name)
			town_name_display.emit(town_name)
			DebugLogger.info("DEBUG: Signal emitted successfully")

			# Show dialog for town entry after a short delay (let welcome text show first)
			DebugLogger.info("DEBUG: About to show town entry dialog")
			await get_tree().create_timer(0.5).timeout  # Wait 0.5 seconds

			# Get GameController to show town dialog
			var game_controller = get_tree().get_first_node_in_group("game_controller")
			if not game_controller:
				# Try to find GameController by traversing up the scene tree
				var node = self
				while node and not node.has_method("show_town_dialog"):
					node = node.get_parent()
				game_controller = node

			DebugLogger.info("DEBUG: Found GameController: %s" % (game_controller != null))
			if game_controller and game_controller.has_method("show_town_dialog"):
				DebugLogger.info("DEBUG: Calling show_town_dialog")
				game_controller.show_town_dialog(town_data)
			else:
				DebugLogger.info("Could not find GameController to show town dialog")

func debug_teleport_to_town():
	"""Debug function to teleport player to a known town location"""
	DebugLogger.info("=== DEBUG TELEPORT TO TOWN ===")
	DebugLogger.info("Current player position BEFORE teleport: %s" % global_position)

	# Find an actual town to teleport to from the terrain data
	DebugLogger.info("Looking for terrain system...")
	var parent_node = get_parent()
	DebugLogger.info("Parent node: %s" % (parent_node.name if parent_node else "null"))
	var parent_children_names = []
	if parent_node:
		for child in parent_node.get_children():
			parent_children_names.append(child.name)
	DebugLogger.info("Parent children: %s" % [parent_children_names])

	var terrain = get_parent().get_node_or_null("EnhancedTerrainTileMap")
	DebugLogger.info("EnhancedTerrainTileMap found: %s" % (terrain != null))
	if not terrain:
		terrain = get_parent().get_node_or_null("EnhancedTerrain")
		DebugLogger.info("EnhancedTerrain found: %s" % (terrain != null))
	if not terrain:
		DebugLogger.error("ERROR: No terrain system found!")
		return

	DebugLogger.info("Terrain system found: %s (class: %s)" % [terrain.name, terrain.get_class()])
	# Search ALL sections for ANY town using direct access to terrain data
	DebugLogger.info("Searching ALL sections for towns...")
	var found_town = false
	var town_world_pos = Vector2.ZERO
	var town_name = "Unknown"
	var towns_found = []

	# Access map sections directly if possible
	if terrain.map_sections and terrain.map_sections.size() > 0:
		DebugLogger.info("Found %s map sections, searching for towns..." % terrain.map_sections.size())

		# Search through all sections for towns
		for section_id in terrain.map_sections.keys():
			var section = terrain.map_sections[section_id]

			# Check if section has town data (new format)
			var town_dict = section.get("town_data")
			if section and town_dict and town_dict is Dictionary and town_dict.size() > 0:
				DebugLogger.info("Section %s has %s towns" % [section_id, town_dict.size()])

				# Get the first available town
				for local_pos in town_dict.keys():
					var town_data = town_dict[local_pos]

					# Convert to world position using terrain's coordinate system
					var global_tile_pos = terrain.world_to_global_tile(local_pos, section_id)
					var world_pos = Vector2(global_tile_pos.x * TILE_SIZE, global_tile_pos.y * TILE_SIZE)

					town_name = town_data.get("name", "Found Town")
					town_world_pos = world_pos
					found_town = true
					towns_found.append({"name": town_name, "pos": world_pos})
					DebugLogger.info("*** FOUND TOWN: '%s' at position: %s ***" % [town_name, town_world_pos])
					break

			# Also check terrain_data for TOWN terrain type (fallback/legacy)
			if not found_town and section.terrain_data:
				DebugLogger.info("  Checking terrain_data for TOWN tiles...")
				for local_pos in section.terrain_data.keys():
					var terrain_type = section.terrain_data[local_pos]
					if terrain_type == terrain.TerrainType.TOWN:
						DebugLogger.info("    FOUND TOWN TERRAIN at local pos: %s" % local_pos)

						# Convert to world position using terrain's coordinate system
						var global_tile_pos = terrain.world_to_global_tile(local_pos, section_id)
						var world_pos = Vector2(global_tile_pos.x * TILE_SIZE, global_tile_pos.y * TILE_SIZE)

						town_name = "Town at " + str(global_tile_pos)
						town_world_pos = world_pos
						found_town = true
						towns_found.append({"name": town_name, "pos": world_pos})
						DebugLogger.info("*** FOUND TOWN TERRAIN: '%s' at position: %s ***" % [town_name, town_world_pos])
						break

			if found_town:
				break
	else:
		DebugLogger.info("No map_sections found or accessible, trying fallback method...")

		# Fallback: try the manual town at (5,5) that we know exists
		var manual_town_pos = Vector2(5 * TILE_SIZE, 5 * TILE_SIZE)
		if terrain.has_method("get_town_data_at_position"):
			var town_data = terrain.get_town_data_at_position(manual_town_pos)
			if not town_data.is_empty():
				town_name = town_data.get("name", "Manual Town")
				town_world_pos = manual_town_pos
				found_town = true
				towns_found.append({"name": town_name, "pos": manual_town_pos})
				DebugLogger.info("*** FOUND MANUAL TOWN: '%s' at position: %s ***" % [town_name, town_world_pos])

	if not found_town:
		DebugLogger.info("No towns found in any section! Creating fallback town at origin")
		town_world_pos = Vector2(0, 0)  # Fallback to origin
		town_name = "Debug Fallback Location"

	DebugLogger.info("TELEPORT SUMMARY:")
	DebugLogger.info("- Found %s towns total" % towns_found.size())
	DebugLogger.info("- Using town: '%s' at position: %s" % [town_name, town_world_pos])

	# Teleport to town center (positions are already treated as centered at tile origin)
	var new_pos = town_world_pos

	DebugLogger.info("Target town tile (top-left): %s" % town_world_pos)
	DebugLogger.info("Target player position (center): %s" % new_pos)

	global_position = new_pos
	current_target_position = new_pos  # Update target to match position
	is_moving = false  # Stop any current movement

	DebugLogger.info("Player teleported to position: %s" % global_position)
	DebugLogger.info("Target position set to: %s" % current_target_position)

	# Immediately center camera and update camera target
	if camera:
		camera.global_position = global_position
		if has_method("set_camera_target"):
			set_camera_target(global_position)

# Override level_up to use proper hit dice
func level_up():
	var old_level = level
	level += 1
	
	DebugLogger.info("LEVEL UP! %s is now level %s" % [character_name, level])
	
	# Roll for HP increase based on class hit die
	var hit_die_roll = 0
	if has_method("roll_class_hit_die"):
		hit_die_roll = call("roll_class_hit_die")
	else:
		# Fallback to a d8 roll
		hit_die_roll = randi() % 8 + 1
	var con_modifier = get_modifier(constitution)
	var hp_gain = hit_die_roll + con_modifier
	hp_gain = max(1, hp_gain)  # Minimum 1 HP per level
	
	max_health += hp_gain
	current_health += hp_gain  # Heal on level-up
	
	DebugLogger.info("Rolled %s on hit die + %s CON mod = %s HP gained!" % [hit_die_roll, con_modifier, hp_gain])
	DebugLogger.info("New max HP: %s" % max_health)
	
	# Recalculate all derived stats
	update_derived_stats()
	
	DebugLogger.info("Level %s -> %s complete!" % [old_level, level])

# Override the base character's gain_experience to add notifications
func gain_experience(xp_amount: int) -> bool:
	var leveled_up = super.gain_experience(xp_amount)
	
	# Show XP notification
	if has_method("show_xp_notification"):
		call("show_xp_notification", xp_amount)
	else:
		# If not present, log the XP gain
		DebugLogger.info("Gained %s XP" % xp_amount)
	
	# If we leveled up, show a level-up notification too
	if leveled_up:
		show_level_up_notification()
	
	return leveled_up

func show_level_up_notification():
	"""Show a prominent level-up notification"""
	var ui_layer = get_parent().get_node_or_null("UI")
	if not ui_layer:
		return
	
	# Create level-up notification
	var level_up_label = Label.new()
	level_up_label.text = "LEVEL UP!"
	level_up_label.add_theme_color_override("font_color", Color.GOLD)
	level_up_label.add_theme_font_size_override("font_size", 36)
	level_up_label.z_index = 101
	
	# Center it on screen
	var viewport_size = get_viewport().size
	level_up_label.position = viewport_size / 2 - Vector2(100, 0)
	
	ui_layer.add_child(level_up_label)
	
	# Animate the level-up notification
	var tween = create_tween()
	tween.tween_property(level_up_label, "scale", Vector2(1.2, 1.2), 0.3)
	tween.tween_property(level_up_label, "scale", Vector2(1.0, 1.0), 0.3)
	tween.tween_delay(1.0)
	tween.tween_property(level_up_label, "modulate:a", 0.0, 0.5)
	tween.tween_callback(level_up_label.queue_free)

# === ENHANCED RANDOM ENCOUNTER SYSTEM ===

func check_for_random_encounter(world_pos: Vector2, terrain_system):
	"""Check for random encounters based on terrain type and player level"""
	
	# Get terrain type at current position
	var terrain_type = get_terrain_type_at_position(world_pos, terrain_system)
	var encounter_chance = get_encounter_chance_for_terrain(terrain_type)
	
	# Scale encounter chance based on player level (higher level = slightly more encounters)
	var level_modifier = 1.0 + (level - 1) * 0.02  # +2% per level above 1
	encounter_chance *= level_modifier
	
	# Cap maximum encounter chance at 25%
	encounter_chance = min(encounter_chance, 0.25)
	
	DebugLogger.info("Encounter check: terrain=%s base_chance=%s final_chance=%s" % [str(terrain_type), str(get_encounter_chance_for_terrain(terrain_type)), str(encounter_chance)])
	
	if encounters_enabled and randf() < encounter_chance:
		DebugLogger.info("Random encounter triggered!")
		encounter_started.emit()

func get_terrain_type_at_position(world_pos: Vector2, terrain_system) -> int:
	"""Get the terrain type at a specific world position"""
	if not terrain_system:
		return 0  # Default to grass
	
	# Convert world position to tile coordinates
	var tile_pos = Vector2i(int(world_pos.x / TILE_SIZE), int(world_pos.y / TILE_SIZE))
	
	# Try to get terrain type from the terrain system
	if terrain_system.has_method("get_terrain_type_at_tile"):
		return terrain_system.get_terrain_type_at_tile(tile_pos)
	elif terrain_system.has_method("get_terrain_at_position"):
		return terrain_system.get_terrain_at_position(world_pos)
	
	# Fallback: check global terrain_data if available (use get() for safe property access)
	var terrain_data = terrain_system.get("terrain_data")
	if terrain_data != null and terrain_data is Dictionary:
		if tile_pos in terrain_data:
			return terrain_data[tile_pos]
	
	# Default to grass
	return 0

func get_encounter_chance_for_terrain(terrain_type: int) -> float:
	"""Return encounter chance based on terrain type"""
	# These should match the TerrainType enum values
	match terrain_type:
		0: return 0.06   # GRASS - moderate encounters
		1: return 0.05   # DIRT - low encounters
		2: return 0.03   # STONE - very low encounters
		3: return 0.02   # WATER - very low encounters
		4: return 0.12   # TREE/FOREST - high encounters
		5: return 0.08   # MOUNTAIN - moderate-high encounters
		6: return 0.07   # VALLEY - moderate encounters
		7: return 0.04   # RIVER - low encounters
		8: return 0.03   # LAKE - low encounters
		9: return 0.01   # OCEAN - very low encounters
		10: return 0.15  # FOREST - highest encounters
		11: return 0.09  # HILLS - moderate-high encounters
		12: return 0.05  # BEACH - low encounters
		13: return 0.08  # SWAMP - moderate-high encounters
		14: return 0.01  # TOWN - very low encounters (civilized)
		_: return 0.06   # Default - moderate encounters

func get_encounter_difficulty_for_terrain(terrain_type: int) -> String:
	"""Return encounter difficulty modifier based on terrain"""
	match terrain_type:
		4, 10: return "forest"      # TREE/FOREST - wolves, bears, bandits
		5, 11: return "mountain"    # MOUNTAIN/HILLS - goblins, orcs, giants
		13: return "swamp"          # SWAMP - undead, reptiles
		3, 7, 8: return "water"     # WATER areas - aquatic creatures
		14: return "civilized"      # TOWN - bandits, guards
		_: return "wilderness"      # Default - standard wilderness encounters

func toggle_combat_log():
	"""Toggle the combat log visibility"""
	# Combat log UI removed; this is a harmless stub to keep older input bindings working.
	# It intentionally does nothing other than log to console for debugging.
	DebugLogger.info(str("toggle_combat_log called, but combat log UI has been removed. No action taken."))

func _exit_tree():
	# Clean up PlayerIconFactory if it exists
	if get_tree() and get_tree().get_root():
		var factory = get_tree().get_root().find_child("PlayerIconFactory", true, false)
		if factory and is_instance_valid(factory):
			if factory.get_parent():
				factory.get_parent().remove_child.call_deferred(factory)
			else:
				factory.queue_free()


